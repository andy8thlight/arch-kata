---
id: "0002"
title: Pricing & Billing Microservice Architecture
status: proposed
date: 2025-10-17
---

## Context and Problem Statement


MobilityCorp processes a wide range of financial events as part of its ride sharing platform (see ADR-001 for external dependency and reliability context):

- Per-minute ride charges (bikes, scooters, cars, vans)
- Pre-authorisations and captures from the payment provider
- Automatic fines (late return, out-of-hub)
- Manual adjustments, refunds, and dispute resolutions
- Premium subscription and concierge fees (optional)

Financial correctness and auditability are critical:
- Every transaction must be **traceable, immutable, and reconcilable**.
- Pricing and fines must follow **configurable policy versions** (see ADR-019 Policy-as-Data).
- Payments occur via an **external PSP (Payment Service Provider)** that enforces Strong Customer Authentication (SCA).

The system therefore requires a **dedicated Billing domain** that serves as the *source of truth* for monetary values across all services. This domain must be resilient to external payment provider outages, support at-least-once delivery semantics, and enable robust reconciliation, as established in ADR-001.

### Questions

- Should billing logic live inside each domain service (Ride, Booking, Policy), or in a dedicated microservice?
- How do we ensure a consistent, tamper-evident financial ledger?
- How can we support refunds, adjustments, and disputes without manual database edits?
- How do we reconcile against the external payment provider’s records?
- Where do we define the boundary between Billing and Policy - does Billing evaluate policy itself, or consume a pre-computed rate?
- What is the interaction pattern with the Payment Provider (sync vs. async)?

---

## Options

### Option 1 – Embed billing logic in each domain service

Each service (Ride, Booking, Policy) calculates its own costs and calls the payment provider directly.

**Pros**
- Simpler initial implementation.
- No additional infrastructure.

**Cons**
- Inconsistent business logic across domains.
- Complex reconciliation; no single ledger.
- Difficult to enforce immutability or auditability.
- Duplicated integration code with payment provider.

---


### Option 2 – Central **Pricing & Billing Microservice**

Create a dedicated microservice responsible for:
- Pricing calculation based on current policy version.
- Ledger of all financial transactions (ride start, fine, refund, etc.).
- Integration with external payment provider, using the Outbox + Worker Queue pattern for all external calls (see ADR-001 for rationale and implementation guidance).
- Emitting financial events to downstream systems (Analytics, Audit Log).

**Pros**
- Single source of truth for all money flows.
- Easier reconciliation and reporting.
- Clear separation between financial logic and operational domains.
- Enables immutable audit trail and external audit export.

**Cons**
- Adds inter-service dependency (Ride → Billing).
- Requires robust idempotency, retry handling, and reconciliation logic for all external payment interactions (see ADR-001 for patterns and requirements).
- Initial complexity higher than embedded approach.

---

### Option 3 – Central ledger but shared “billing library”

Maintain a shared code library for billing logic; each service writes to a shared financial database schema.

**Pros**
- Consistent calculations via library reuse.
- No new service to deploy.

**Cons**
- Shared database violates service-ownership boundaries.
- Library updates require cross-team coordination.
- Harder to version pricing rules per service.

---

## Decision
---

We will adopt **Option 2 – Central Pricing & Billing Microservice**, with strict adherence to the reliability, idempotency, and reconciliation patterns established in ADR-001.

**Rationale:**
- Centralizing billing logic ensures a single source of truth for all financial transactions, supporting traceability, auditability, and regulatory compliance.
- By integrating with the external payment provider via the Outbox + Worker Queue pattern (ADR-001), we ensure resilience to provider outages, at-least-once delivery, and robust error handling.
- This approach enables consistent monitoring, metrics, and reconciliation across all money flows, aligning with the operational and reliability standards set for the platform.
- While it introduces some complexity, the benefits in correctness, maintainability, and operational visibility are essential for a financial system in a ride sharing context.

Options 1 and 3 were rejected due to their inability to guarantee a consistent, tamper-evident ledger and to support the reliability and reconciliation requirements outlined in ADR-001.
## Consequences

**Follow-ups**
- Define canonical event schema (`charge_initiated`, `charge_captured`, `refund_processed`).
- Specify reconciliation job frequency and retention policy, ensuring alignment with the reconciliation and monitoring strategies in ADR-001.
- Decide on storage technology (likely PostgreSQL with append-only ledger pattern).
- Integrate with Immutable Audit Log (ADR-013) for cryptographic proof of integrity.
- Expose read-only APIs for reporting and analytics consumers.
- Ensure all external payment provider interactions use the Outbox + Worker Queue pattern, with metrics and alerting as described in ADR-001.

---