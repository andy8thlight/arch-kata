---
id: "0010"
title: Routing & Hub-Slot Reservation Integration
status: proposed
date: 2025-10-21
---

## Context and Problem Statement

To optimise field operations, MobilityCorp must allow users to **reserve hub slots** (charging, maintenance, or loading bays) directly within the routing workflow.  

When a user enters a destination, the **Routing Solver (ADR-005)** should integrate with a **Hub-Slot Reservation Service** that:

- Identifies the nearest hub or depot to the final destination.  
- Checks **slot availability** for the projected arrival window.  
- **Reserves** a slot automatically or recommends alternatives.  
- Integrates with external mapping (Google Maps API) for distance and ETA calculation.  
- Operates with **low latency**, ensuring route recalculation remains responsive.

The goal is to unify **route planning** and **hub logistics**, reducing downtime, congestion, and manual coordination.

---

## Questions

- Should reservation logic run inside the Routing Solver or as a standalone service?  
- How should Google Maps (or equivalent) be integrated — synchronous API call or cached service?  
- How are conflicts handled when multiple vehicles target the same slot?  
- Should reservations be provisional (soft) or hard-locked immediately?  
- How can cancellations and reschedules be propagated in real time?

---

## Options

### Option A — Manual Hub Reservation
Operators manually select and book hub slots via a separate interface after routing.

**Pros**
- Simplest implementation.  
- No cross-system coupling.

**Cons**
- Manual and error-prone.  
- Breaks routing automation and user flow.  
- No predictive optimisation.

---

### Option B — Integrated Logic Inside Routing Solver
Extend the Routing Solver (ADR-005) to directly query Google Maps and hub APIs during optimisation.

**Pros**
- Unified logic; minimal network hops.  
- Simplified API exposure.

**Cons**
- Tight coupling of external API dependencies.  
- Reduced modularity; harder to evolve or scale.  
- Longer route computation times.

---

### Option C — Microservice-Based Integration (Recommended)
Introduce a dedicated **Hub-Slot Reservation Service** operating independently of the solver.  
The Routing Solver calls it asynchronously once a route or destination candidate is determined.

- Service queries Google Maps (or cached routing service) for distance and ETA.  
- Checks nearest hub availability via internal API or Kafka topic.  
- Reserves an appropriate slot and returns confirmation or alternatives.  
- Updates Databricks and Audit Log for analytics and traceability.

**Pros**
- Decoupled and reusable across multiple routing contexts.  
- Parallelisable calls (solver → reservation).  
- Integrates cleanly with the event-driven platform (ADR-007).  
- Future extensibility to ML-based demand forecasting.  

**Cons**
- Additional network and service overhead.  
- Requires consistent latency and SLA management.

---

## Recommendation

Adopt **Option C – Microservice-Based Integration** between the **Routing Solver (ADR-005)** and a **Hub-Slot Reservation Service**.  

Key design principles:

1. **Loose coupling** – reservation handled asynchronously; solver remains focused on optimisation.  
2. **API + Event interface** – synchronous REST call for immediate slot confirmation; Kafka event for downstream analytics.  
3. **Fallback logic** – if hub slot unavailable, solver suggests nearest alternative or queues reservation retry.  
4. **Google Maps Integration** – wrapped via internal caching service to control API quotas and latency.  
5. **Auditability** – every reservation, change, or cancellation logged to Databricks (ADR-007) and the immutable audit store (ADR-013).

---

## Consequences

**Positive**
- Seamless user experience: route + slot reserved in one flow.  
- Scalable architecture with clear separation of concerns.  
- Enables predictive scheduling and capacity analytics.  

**Trade-offs**
- Adds an additional service dependency and SLA requirement.  
- Requires data synchronisation between hub state and central platform.  
- Slight increase in routing latency due to external calls.

---

## Implementation Details (High-level)

| Component | Responsibility | Notes |
|---|---|---|
| **Routing Solver Service** | Generate optimised route and ETA | See ADR-005 |
| **Hub-Slot Reservation Service** | Query hub APIs, reserve slot, manage conflicts | Internal microservice with REST + Kafka interface |
| **Google Maps API (or cache)** | Compute distances and travel times | Accessed via proxy/cache to limit API calls |
| **Kafka / Event Bus** | Publish reservation events | Shared platform (ADR-007) |
| **Databricks Lakehouse** | Store reservation metrics and outcomes | Supports analytics and SLA dashboards |
| **Audit Log** | Immutable record of reservations and cancellations | See ADR-013 |
| **Mobile / Web App** | Display reserved slot, update upon change | Integrates with Personalisation (ADR-009) |

**Sequence Example**
```mermaid
sequenceDiagram
    title Routing & Hub-Slot Reservation Integration Flow

    participant APP as Mobile / Web App
    participant SOLV as Routing Solver
    participant RESV as Hub-Slot Reservation Service
    participant MAPS as Google Maps API / Cache
    participant HUB as Hub Mgmt System
    participant BUS as Kafka (Event Bus)
    participant DWH as Databricks
    participant AUD as Audit Log

    APP->>SOLV: Submit destination / route request
    SOLV->>MAPS: Request distance and ETA
    MAPS-->>SOLV: Return route ETA and coordinates
    SOLV->>RESV: Request hub slot for destination
    RESV->>HUB: Check hub availability
    HUB-->>RESV: Return available slots
    RESV->>RESV: Reserve nearest available slot
    RESV-->>SOLV: Return reservation confirmation
    RESV->>BUS: Publish reservation event
    BUS-->>DWH: Store metrics and slot usage
    RESV->>AUD: Log reservation details
    SOLV-->>APP: Return optimised route + slot details

---

## Risks and Mitigations

| Risk                                    | Likelihood | Impact | Mitigation                                            |
| --------------------------------------- | ---------: | -----: | ----------------------------------------------------- |
| Google Maps API quota exceeded          |        Med |    Med | Implement caching and rate limiting proxy             |
| Slot overbooking due to race conditions |        Med |   High | Use atomic reservation in hub system                  |
| Increased latency from external calls   |        Med |    Med | Parallel async calls; graceful degradation            |
| Hub data desync between systems         |        Low |   High | Periodic sync and reconciliation job                  |
| API outage or timeout                   |        Med |   High | Retries with exponential backoff; fallback suggestion |
| User confusion on reservation failure   |        Low |    Med | Clear UI messaging and alternative slot options       |


---

## Alternatives Considered

* Manual booking workflow – rejected for inefficiency.
* Embedded hub logic in solver – rejected for coupling and latency concerns.
* Dedicated microservice with caching and audit – chosen for scalability, resilience, and modularity.

## Links

* ADR-002 – External Dependency SLA & Retry Handling
* ADR-005 – Routing Solver (VRP-TW)
* ADR-006 – Alerts & Theft Detection Logic
* ADR-007 – Data Platform Architecture
* ADR-009 – Personalisation / Concierge Service Architecture
* ADR-013 – Immutable Audit Log Architecture
* ADR-016 – AI Interchange Layer