
---
id: "0010"
title: Routing & Hub-Slot Reservation Integration
status: proposed
date: 2025-10-21
---



## Context and Problem Statement

MobilityCorp, as a multi-region ride sharing and fleet operations platform, must unify **route planning** and **hub logistics** to reduce downtime, congestion, and manual coordination. To optimise field operations, users must be able to **reserve hub slots** (charging, maintenance, or loading bays) directly within the routing workflow.

When a user enters a destination, the **Routing Solver (ADR-005)** should integrate with a **Hub-Slot Reservation Service** that:
- Identifies the nearest hub or depot to the final destination
- Checks **slot availability** for the projected arrival window
- **Reserves** a slot automatically or recommends alternatives
- Integrates with external mapping (Google Maps API) for distance and ETA calculation
- Operates with **low latency**, ensuring route recalculation remains responsive

This ADR builds on the event-driven, microservice, and reliability patterns established in [ADR-001](./001.md), [ADR-002](./002.md), [ADR-003](./003.md), [ADR-005](./005.md), [ADR-007](./007.md), and [ADR-009](./009.md).

---

---


### Key Questions

- Should reservation logic run inside the Routing Solver or as a standalone service?
- How should Google Maps (or equivalent) be integrated — synchronous API call or cached service?
- How are conflicts handled when multiple vehicles target the same slot?
- Should reservations be provisional (soft) or hard-locked immediately?
- How can cancellations and reschedules be propagated in real time?

---




## Options


### Key Questions

- Should reservation logic run inside the Routing Solver or as a standalone service?
- How should Google Maps (or equivalent) be integrated — synchronous API call or cached service?
- How are conflicts handled when multiple vehicles target the same slot?
- Should reservations be provisional (soft) or hard-locked immediately?
- How can cancellations and reschedules be propagated in real time?

---


### Option A — Manual Hub Reservation
Operators manually select and book hub slots via a separate interface after routing.

**Pros**
- Simplest implementation
- No cross-system coupling

**Cons**
- Manual and error-prone
- Breaks routing automation and user flow
- No predictive optimisation

---

### Option B — Integrated Logic Inside Routing Solver
Extend the Routing Solver (ADR-005) to directly query Google Maps and hub APIs during optimisation.

**Pros**
- Unified logic; minimal network hops
- Simplified API exposure

**Cons**
- Tight coupling of external API dependencies
- Reduced modularity; harder to evolve or scale
- Longer route computation times

- Service queries Google Maps (or cached routing service) for distance and ETA
- Reserves an appropriate slot and returns confirmation or alternatives
- Updates Databricks and Audit Log for analytics and traceability
- Future extensibility to ML-based demand forecasting
**Cons**
- Additional network and service overhead
- Requires consistent latency and SLA management



We will adopt **Option C – Microservice-Based Integration** between the **Routing Solver (ADR-005)** and a **Hub-Slot Reservation Service**.
- Policy-as-Data (ADR-003) enables versioned, auditable, and configurable reservation rules.
- Reservation outcomes and alternatives are surfaced to users via the Personalisation/Concierge Service (ADR-009).

2. **Reliability & Idempotency:** All reservation requests and state changes are processed via an Outbox + Worker Queue pattern (ADR-001), ensuring at-least-once delivery, idempotency, and robust retry/reconciliation for both API and event flows. Duplicate or conflicting reservations are detected and resolved atomically.
4. **API & Event Schema:** The Reservation Service exposes a REST API for synchronous slot confirmation and emits events (e.g., `reservation.created`, `reservation.failed`, `reservation.cancelled`) to Kafka for downstream analytics, audit, and notification. All schemas are versioned and documented.
5. **Analytics & Data Platform:** All reservation events and outcomes are ingested into the Data Platform (ADR-007) and Databricks Lakehouse for real-time analytics, SLA dashboards, and operational monitoring. Metrics include reservation success/failure rates, latency, and slot utilisation.
---
---

- Enables predictive scheduling, capacity analytics, and proactive recommendations
- Extensible to future ML-based demand forecasting and policy evolution

**Negative Consequences / Trade-offs:**
- Adds an additional service dependency and SLA requirement
- Requires data synchronisation between hub state and central platform
- Slight increase in routing latency due to external calls and event processing
- Increased complexity in policy management, event schema versioning, and operational monitoring

**Stakeholders:**
- Platform Engineering: responsible for Reservation Service development, integration, and maintenance
- Data Engineering: responsible for event schemas, analytics, and data platform integration
- Mobile/Web Engineering: responsible for user experience and integration with Personalisation
- Compliance and Legal: oversee audit, privacy, and regulatory requirements

**Reliability and Integration:**
- All reservation requests, state changes, and events must use reliable, idempotent delivery patterns as established in [ADR-001](./001.md) (e.g., Outbox + Worker Queue for Kafka topics).
- Downstream consumers must be able to handle retries, late or missing events, and ensure at-least-once processing semantics.

**Audit and Compliance:**
- All reservation events, API calls, and policy changes must be logged to the Immutable Audit Log ([ADR-013](./013.md)) and be accessible for compliance review.
- Regular audits and SLA reviews must be scheduled and owned by Platform Engineering and Compliance teams. Audit frequency: quarterly, or after any major incident. Compliance team is responsible for regulatory monitoring and escalation.

**Implementation and Rollout Plan:**
1. Develop and document canonical API and event schemas for all Reservation Service topics.
2. Build and validate Reservation Service, policy management, and integration with Routing Solver.
3. Integrate with downstream consumers ([ADR-005](./005.md), [ADR-007](./007.md), [ADR-009](./009.md), [ADR-013](./013.md)) and ensure reliable event delivery.
4. Register all schemas and log all pipeline events to the Audit Log ([ADR-013](./013.md)).
5. Establish monitoring dashboards and alerting for Reservation Service health, latency, and event delivery failures.
6. Communicate rollout plan, milestones, and responsibilities to all stakeholders via regular project updates and review meetings.

**Follow-ups / Open Issues:**
- Finalize event schemas and data contracts with all consuming and producing services.
- Define SLAs for reservation latency, reliability, and auditability.
- Review and update compliance documentation as regulations evolve (see GDPR/Data Privacy section).
- Confirm stakeholder sign-off at each rollout milestone.
- Track open integration issues with hub APIs and update risk register as needed.
- Establish feedback loop for schema evolution: all schema changes must be reviewed by Data Engineering, validated by downstream consumers, and communicated to all stakeholders before deployment. Breaking changes require a deprecation notice and migration plan.
- Document and test incident response and escalation procedures for reservation failures, data quality issues, and compliance breaches (see Incident Response & Escalation section).
- Monitor and address open issues related to hub data synchronisation, latency, and provider API changes.

---

---




## Implementation Details (High-level)

| Component | Responsibility | Notes |
|---|---|---|
| **Routing Solver Service** | Generate optimised route and ETA | See ADR-005; calls Reservation Service via API |
| **Hub-Slot Reservation Service** | Query hub APIs, reserve slot, manage conflicts | Outbox + Worker Queue, REST + Kafka, policy-as-data |
| **Policy Service** | Manage reservation rules, priorities, overbooking | Policy-as-Data (ADR-003); versioned, auditable |
| **Google Maps API (or cache)** | Compute distances and travel times | Accessed via proxy/cache to limit API calls |
| **Kafka / Event Bus** | Publish reservation events | Shared platform (ADR-007); event schemas versioned |
| **Databricks Lakehouse** | Store reservation metrics and outcomes | Supports analytics and SLA dashboards |
| **Audit Log ([ADR-013](./013.md))** | Immutable record of reservations and cancellations | Tamper-evident ledger |
| **Mobile / Web App** | Display reserved slot, update upon change | Integrates with Personalisation (ADR-009) |
| **Concierge/Personalisation** | Surface recommendations, alternatives, explanations | See ADR-009; user-facing feedback loop |

**Sequence Example**

1. User requests route to destination in Mobile/Web App
2. Routing Solver (ADR-005) generates candidate route and ETA
3. Routing Solver calls Hub-Slot Reservation Service (API)
4. Reservation Service checks policy, slot availability, and ETA
5. Reservation Service reserves slot (or suggests alternatives), emits `reservation.created`/`reservation.failed` event to Kafka
6. Reservation outcome is logged to Audit Log (ADR-013) and Databricks (ADR-007)
7. Mobile/Web App displays reserved slot or alternatives, with explanation via Concierge/Personalisation (ADR-009)

![Sequence Diagram](https://github.com/user-attachments/assets/518dce4f-cb57-4817-bf81-fd0a79367db4)

---




## Risks and Mitigations

| Risk                                    | Likelihood | Impact | Mitigation                                            |
|-----------------------------------------|:----------:|:------:|------------------------------------------------------|
| Google Maps API quota exceeded          |    Med     |  Med   | Implement caching and rate limiting proxy             |
| Slot overbooking due to race conditions |    Med     | High   | Use atomic reservation in hub system                  |
| Increased latency from external calls   |    Med     |  Med   | Parallel async calls; graceful degradation            |
| Hub data desync between systems         |    Low     | High   | Periodic sync and reconciliation job                  |
| API outage or timeout                   |    Med     | High   | Retries with exponential backoff; fallback suggestion |
| User confusion on reservation failure   |    Low     |  Med   | Clear UI messaging and alternative slot options       |

---




## Alternatives Considered

* Manual booking workflow – rejected for inefficiency
* Embedded hub logic in solver – rejected for coupling and latency concerns
* Dedicated microservice with caching and audit – chosen for scalability, resilience, and modularity


## Related ADRs

- [ADR-001 – External Dependency SLA & Retry Handling](./001.md)
- [ADR-002 – Pricing & Billing Microservice Architecture](./002.md)
- [ADR-005 – Routing Solver (VRP-TW)](./005.md)
- [ADR-006 – Alerts & Theft Detection Logic](./006.md)
- [ADR-007 – Data Platform Architecture](./007.md)
- [ADR-009 – Personalisation / Concierge Service Architecture](./009.md)
- [ADR-013 – Immutable Audit Log Architecture](./013.md)
- [ADR-016 – AI Interchange Layer](./016.md)
