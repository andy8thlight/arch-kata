---
id: "0011"
title: Immutable Audit Log Architecture
status: proposed
date: 2025-10-21
---

## Context and Problem Statement

MobilityCorp’s platform handles **mission-critical events** — such as billing adjustments, consent updates, routing decisions, and security actions — that require **tamper-evident traceability** for regulatory, operational, and forensic purposes.

The current logs (application and analytics) provide observability but are **not immutable**; privileged users or processes could theoretically modify or delete records.  
To satisfy compliance, audit, and AI explainability requirements, the system must maintain an **append-only, verifiable, and independently auditable ledger** of key events across domains.

The audit architecture must ensure:
- **Integrity:** entries cannot be modified or deleted post-write.  
- **Non-repudiation:** each record verifiably tied to an origin and hash chain.  
- **Accountability:** every action traceable to a user, service, or automated agent.  
- **Compliance:** alignment with GDPR, ISO-27001, and SOC-2 evidence standards.

---

## Questions

- Should immutability be enforced at the storage layer (e.g., WORM, blockchain) or via cryptographic append-only indexing?  
- How can we validate integrity efficiently at scale?  
- Which classes of events warrant inclusion (billing, consent, policy, routing)?  
- How will audit records be queried and verified across microservices?  
- How is data residency and retention managed for compliance?

---

## Options

### Option A — Standard Relational Audit Table
Store audit entries in an RDBMS (e.g., PostgreSQL) with access controls and “no update/delete” policies.

**Pros**
- Simple implementation.  
- Queryable with existing tools.

**Cons**
- Still mutable by privileged users.  
- No cryptographic proof of integrity.  

---

### Option B — Blockchain-based Ledger
Use a distributed ledger or managed blockchain service (e.g., AWS QLDB, Hyperledger Fabric) to enforce immutability.

**Pros**
- Strong cryptographic guarantees and independent verification.  
- Built-in append-only and hash-chain semantics.

**Cons**
- Operationally heavy; higher cost and latency.  
- Overkill for internal compliance use case.  

---

### Option C — Hash-Chained Append-Only Log (Recommended)
Implement an **internal immutable audit service** that writes append-only records to durable storage (e.g., S3, Databricks Delta, or append-only Postgres).  
Each entry contains:
- A **cryptographic hash** of its contents.  
- The **hash of the previous record**, forming a verifiable chain.  
- A **signature** from the writing service or user identity.  

Verification routines can periodically recompute hashes to prove integrity.

**Pros**
- Cryptographically tamper-evident but lightweight.  
- Compatible with existing data platform (ADR-007).  
- Low latency; easy to integrate across services via Kafka.  
- Auditable by third-party verifiers.  

**Cons**
- Requires disciplined write-once semantics.  
- Verification and rotation logic must be carefully maintained.  

---

## Recommendation

Adopt **Option C – Hash-Chained Append-Only Audit Log** as a shared compliance component.

**Key design decisions**
1. **Write-Once, Append-Only:** all writes are immutable; deletions prohibited.  
2. **Hash Chain Verification:** each record stores its own hash and the hash of the prior entry.  
3. **Service Signatures:** origin service signs each record using its keypair.  
4. **Kafka Ingestion Path:** critical events (billing, consent, routing, policy changes) published to a dedicated audit topic.  
5. **Ledger Storage:** append-only table in Databricks or S3-based Delta Lake.  
6. **Verification Jobs:** scheduled tasks validate hash chains and emit alerts if discrepancies occur.  
7. **Queryable Index:** authorised users can read via API or warehouse view but never modify entries.

---

## Consequences

**Positive**
- Provides tamper-evident, independently verifiable audit trail.  
- Strengthens compliance posture (SOC-2, GDPR Article 30).  
- Enables cross-system traceability for AI explainability and dispute resolution.  

**Trade-offs**
- Slight storage and compute overhead for hashing.  
- Verification processes add operational complexity.  
- Write performance slightly slower due to signature generation.

---

## Implementation Details (High-level)

| Component | Responsibility | Notes |
|---|---|---|
| **Audit Producer (services)** | Emit signed audit events to Kafka | E.g., Billing, Policy, Routing |
| **Kafka (Audit Topic)** | Transport immutable audit messages | Partitioned by domain |
| **Audit Log Service** | Validate signatures, append to ledger | Stateless microservice |
| **Ledger Storage (Databricks / Delta Lake)** | Store append-only hash chain | EU-resident, write-once policy |
| **Hash Verifier Job** | Recompute hashes, verify chain integrity | Alerts discrepancies via Slack/SIEM |
| **Audit API (read-only)** | Provide controlled query access | Enforced RBAC and masking |
| **Compliance Dashboard** | Visualise verification state and anomalies | Used by internal audit & InfoSec |

**Sequence Example**


---

## Risks and Mitigations

| Risk                                  | Likelihood | Impact | Mitigation                             |
| ------------------------------------- | ---------: | -----: | -------------------------------------- |
| Hash chain corruption or mismatch     |        Low |   High | Regular verification and alerting      |
| Unauthorized access to raw audit data |        Low |   High | Enforced RBAC; encryption at rest      |
| Key compromise of signing services    |        Med |   High | Key rotation and HSM-backed signing    |
| Excessive log growth                  |        Med |    Med | Tiered storage, retention policy       |
| Verification job failure              |        Med |    Med | Health checks and fallback audit trail |
| Performance overhead                  |        Low |    Low | Batched hash computation               |

---

## Alternatives Considered

* Relational audit tables – rejected due to mutability.
* Blockchain ledger – rejected due to operational overhead.
* Internal hash-chained append-only ledger – chosen for efficiency and compliance fit.

## Links

* ADR-002 – External Dependency SLA & Retry Handling
* ADR-006 – Alerts & Theft Detection Logic
* ADR-007 – Data Platform Architecture
* ADR-008 – Mobile Offline Sync Strategy
* ADR-009 – Personalisation / Concierge Service Architecture
* ADR-010 – Routing & Hub-Slot Reservation Integration
* ADR-016 – AI Interchange Layer


