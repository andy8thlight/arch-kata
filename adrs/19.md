---
id: "0019"
title: Policy-as-Data Framework
status: proposed
date: 2025-10-22
---

## Context and Problem Statement

MobilityCorp’s operational rules — such as **pricing models**, **fines**, **routing constraints**, and **eligibility logic** — are currently embedded in service code or configuration files.  
This approach leads to:
- Slow iteration cycles for policy changes.  
- High deployment overhead for non-technical users (finance, ops, compliance).  
- Poor traceability and limited ability to audit or experiment safely.

A **Policy-as-Data Framework** treats policies as structured, versioned data managed in a dedicated service.  
This enables:
- Dynamic evaluation of rules without redeploying code.  
- Controlled experimentation (A/B testing, shadow evaluation).  
- Transparent change history with full auditability (see ADR-011).  
- Simplified rollback and analytics on policy effects.

---

## Questions

- Should policies be expressed as code (e.g., rules engine) or stored as declarative data?  
- How can we validate and deploy policy changes safely across environments?  
- What versioning and approval workflow is required for compliance?  
- How do we link policies to business metrics (pricing accuracy, violation rate)?  
- How can policy decisions be explained and audited post-hoc?

---

## Options

### Option A — Static Configuration in Code
Policies defined in application source or YAML files, redeployed with each release.

**Pros**
- Simple implementation.  
- Strong type safety and code review process.

**Cons**
- Requires engineer intervention for every change.  
- Difficult to experiment or rollback.  
- Limited audit trail and approval workflow.

---

### Option B — Rules Engine Embedded per Service
Each service implements a local policy engine (e.g., Drools, RuleBook).

**Pros**
- Local evaluation; low latency.  
- Some runtime flexibility.

**Cons**
- Inconsistent policy definitions across services.  
- Hard to coordinate cross-domain policies.  
- Duplication of logic and governance risk.

---

### Option C — Central Policy-as-Data Service (Recommended)
Introduce a **dedicated Policy Service** that stores and versions policy definitions as structured data (e.g., JSON/Parquet in Delta tables).  
Services fetch, cache, and evaluate policies at runtime.  
All changes are tracked, reviewed, and auditable.

**Pros**
- Centralised source of truth for all operational policies.  
- Supports experimentation and instant rollback.  
- Full traceability via Audit Log (ADR-011).  
- Compatible with event-driven architecture (ADR-007).  

**Cons**
- Adds network dependency for policy fetches.  
- Requires schema validation and governance process.

---

## Recommendation

Adopt **Option C – Central Policy-as-Data Service** to manage all pricing, fine, and routing policies as versioned data assets.

**Key design decisions**
1. **Policy Registry:** versioned dataset (e.g., Delta table) with metadata, owner, approval state, and effective date.  
2. **Evaluation API:** lightweight microservice providing policy lookups and evaluation context to downstream systems.  
3. **Change Workflow:** policy proposals created via UI or API → reviewed → approved → published.  
4. **Auditability:** all changes, approvals, and evaluations logged to the **Immutable Audit Log (ADR-011)**.  
5. **Experimentation:** supports A/B and time-windowed policy activation; integrates with analytics (ADR-007).  
6. **Observability:** metrics (lookup latency, hit ratio, policy version) exported to ADR-013 dashboards.  
7. **Caching:** local in-service cache with TTL and version checks to reduce latency.

---

## Consequences

**Positive**
- Enables business teams to modify pricing/fine logic safely.  
- Improves auditability and rollback.  
- Accelerates experimentation and policy tuning.  
- Reduces coupling between business logic and code deployments.

**Trade-offs**
- Requires strong schema validation and approval workflows.  
- Introduces a dependency on the central Policy Service.  
- Additional governance overhead to prevent inconsistent policies.

---

## Implementation Details (High-level)

| Component | Responsibility | Notes |
|---|---|---|
| **Policy Registry (Delta / Databricks)** | Store versioned policy data and metadata | EU-resident; integrated with CI/CD |
| **Policy Service API** | Expose latest and historical policy versions | JSON schema validation; REST + Kafka interface |
| **Evaluation Client (SDK)** | Fetch and evaluate policy locally | Cached for performance |
| **Kafka / Event Bus (ADR-007)** | Broadcast policy change events | Supports downstream sync |
| **Databricks Lakehouse** | Analyse policy impact and performance | Supports experimentation analytics |
| **Audit Log (ADR-011)** | Immutable log of policy changes and evaluations | Verifiable chain |
| **Observability Stack (ADR-013)** | Monitor lookup latency, version usage | Unified metrics schema |

**Sequence Example**

<img width="3990" height="1652" alt="19" src="https://github.com/user-attachments/assets/84f61796-6f57-4c04-8670-654545b85abe" />

---

## Risks and Migrations

| Risk                                    | Likelihood | Impact | Mitigation                                           |
| --------------------------------------- | ---------: | -----: | ---------------------------------------------------- |
| Invalid or conflicting policy versions  |        Med |   High | Schema validation, staged rollout, approval workflow |
| Service outage blocks policy fetch      |        Low |   High | Local cache and fallback policy                      |
| Policy tampering or unauthorised change |        Low |   High | Immutable Audit Log and RBAC                         |
| Slow adoption across teams              |        Med |    Med | Training and shared governance templates             |
| Excessive experimentation cost          |        Med |    Med | Budget guardrails (ADR-018)                          |

---

## Alternatives Considered

* Static code-based policies – rejected for inflexibility.
* Per-service rule engines – rejected for inconsistency.
* Central Policy-as-Data model – chosen for auditability, agility, and compliance.

## Links

* ADR-007 – Data Platform Architecture
* ADR-011 – Immutable Audit Log Architecture
* ADR-013 – Observability & Metrics Standardisation
* ADR-014 – AI Interchange Layer Architecture
* ADR-018 – AI Cost & Budget Guardrails
* ADR-017 – AI Governance & Explainability Framework
