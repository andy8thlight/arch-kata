---
id: "0014"
title: AI Interchange Layer Architecture
status: proposed
date: 2025-10-22
---

## Context and Problem Statement

MobilityCorp runs multiple AI capabilities across European regions: **Demand Prediction (ADR-004)**, **Routing Solver (ADR-005)**, and **Concierge (ADR-009)**.  
Direct, per-service integrations with model hosts lead to **duplicated logic**, **inconsistent consent and cost controls**, and **fragmented observability**.

We require a **central AI Interchange Layer** that:
- Exposes a **unified API** for AI tasks (predict, route_assist, personalise).  
- Enforces **consent**, **policy**, and **subscription tier** at the AI edge.  
- Retrieves **region-aware features** (weather, transport) from the Feature Store (ADR-016).  
- Handles **provider routing** and **cost governance** (ADR-018).  
- Captures **explainability metadata** and logs to **Audit Log (ADR-011)**.  

---

## Questions

- Network service vs shared SDK — where should governance and routing live?  
- How to route by **region, capability, latency, cost**, and **AB tests**?  
- What minimal data to persist for **explainability** while meeting GDPR?  
- How to integrate **Feature Store** for live inference context?  
- How to keep **costs predictable** and **SLOs** reliable?

---

## Options

### Option A — Per-Service Direct Integration
Each microservice calls models and handles its own consent/cost/telemetry.

**Pros**
- Simple for one team to start.
**Cons**
- Duplicated effort; weak governance and inconsistent metrics.

---

### Option B — Shared Client Library Only
A common SDK adds headers, logging, and retries.

**Pros**
- Faster adoption than a new service.
**Cons**
- Still fragmented policy enforcement; limited runtime routing and quotas.

---

### Option C — Central AI Interchange Service (Recommended)
A **network service** is the single entry for AI tasks, with a thin SDK.  
It applies **policy and consent checks**, performs **feature retrieval**, routes to **model endpoints**, captures **cost and explainability**, and returns results.

**Pros**
- Uniform governance, routing, and cost control.  
- Pluggable providers; rapid model swaps and canaries.  
- One place for observability and audit.
**Cons**
- Adds a runtime hop; must meet strict SLOs.

---

## Recommendation

Adopt **Option C – Central AI Interchange Service** with region-aware routing and feature retrieval.

**Key decisions**
1. **Unified Task API**  
   Standard envelope: `task_type`, `region_code`, `inputs_ref`, `user_tier`, `trace_id`.
2. **Policy & Consent Gate**  
   Check consent, PII redaction, and tier (ADR-012, ADR-019) before inference.
3. **Feature Retrieval**  
   Pull live **weather/transport/demand** features from **Feature Store (ADR-016)** when required.
4. **Provider Router**  
   Route to **SageMaker EU endpoints** (ADR-015) or external providers using rules for capability, latency, and cost; support canary and AB.
5. **Cost Governance**  
   Emit per-call usage to **AI Cost Guardrails (ADR-018)** with budgets by team, model, and region.
6. **Explainability Journal**  
   Store minimal metadata and rationale; hash-link to **Audit Log (ADR-011)**; expose summaries via **ADR-017**.
7. **Observability**  
   OTel traces, histograms, and error codes per task; SLOs via ADR-013.

---

## Consequences

**Positive**
- Consistent consent, cost, and explainability controls across all AI usage.  
- Faster provider swaps and safer experiments.  
- Predictable spend with budget enforcement.

**Trade-offs**
- Interchange must scale horizontally and avoid becoming a bottleneck.  
- Requires migration from direct integrations to the unified API.

---

## Implementation Details (High-level)

| Component | Responsibility | Notes |
|---|---|---|
| **Interchange API** | Single entrypoint for AI tasks | REST + async; thin SDK for callers |
| **Policy & Consent Gate** | Validate consent, PII, user tier | Integrates IdP, ADR-012, ADR-019 |
| **Feature Connector** | Fetch region-aware features | Reads from Feature Store (ADR-016) |
| **Provider Router** | Select endpoint by rules and health | Supports canary, AB, fallbacks |
| **Cost Meter** | Record tokens, latency, cost | Publishes to ADR-018, DWH |
| **Explainability Journal** | Persist minimal metadata | Linked to ADR-011, surfaced via ADR-017 |
| **Observability Agent** | OTel traces/metrics/logs | Dashboards via ADR-013 |
| **Model Hosting** | Serve models in EU | SageMaker endpoints (ADR-015) |

**Sequence Example**

<img width="4618" height="1458" alt="14" src="https://github.com/user-attachments/assets/13a31009-c407-4e31-9d7b-1e1f6cd9bfcb" />

---

## Risks and Mitigations

| Risk                           | Likelihood | Impact | Mitigation                                       |
| ------------------------------ | ---------: | -----: | ------------------------------------------------ |
| Interchange becomes bottleneck |        Med |   High | Horizontal scale, autoscaling, circuit breakers  |
| Provider outage or drift       |        Med |   High | Multi-provider routing, health checks, fallbacks |
| Sensitive data leakage         |        Low |   High | Redaction, consent checks, data minimisation     |
| Cost overruns                  |        Med |    Med | Budgets and quotas via ADR-018                   |
| Schema or task-version sprawl  |        Med |    Med | Versioned contracts, SDK validation in CI        |
| Region misrouting              |        Low |    Med | Strict `region_code` validation and tests        |

---

## Alternatives Considered

* Per-service direct model calls — rejected for governance and cost visibility gaps.
* SDK-only wrapper — rejected for limited runtime enforcement and routing.
* Central Interchange — chosen for unified control and regional feature integration.

## Links

* ADR-004 – Demand Prediction Model
* ADR-005 – Routing Solver (VRP-TW)
* ADR-007 – Data Platform Architecture
* ADR-009 – Concierge / Personalisation Service Architecture
* ADR-011 – Immutable Audit Log Architecture
* ADR-012 – Premium Subscription Model Integration
* ADR-013 – Observability & Metrics Standardisation
* ADR-015 – Model Hosting & Inference Strategy
* ADR-016 – AI Data Pipeline & Feature Store Design
* ADR-017 – AI Governance & Explainability Framework
* ADR-018 – AI Cost & Budget Guardrails
* ADR-019 – Policy-as-Data Framework

---
id: "0014"
title: AI Interchange Layer Architecture
status: proposed
date: 2025-10-22
---

## Context and Problem Statement

MobilityCorp is introducing multiple AI capabilities across domains: **forecasting**, **routing assistant**, **anomaly detection**, **concierge personalisation**, and more.  
Today, individual services call models directly, leading to **duplicated integrations**, **inconsistent cost tracking**, and **fragmented consent and explainability controls**.

We need a **central AI Interchange Layer** that:
- Exposes a unified API for AI tasks and models.  
- Manages **provider selection**, **cost tracking**, **rate limits**, and **quotas**.  
- Enforces **consent checks** and **PII policies** before inference.  
- Captures **prompts, inputs metadata, and outputs** for **explainability** and **audit** (see ADR-011).  
- Integrates with the **Data Platform** (ADR-007), **Observability** (ADR-013), and **Subscription/Entitlements** (ADR-012).

---

## Questions

- Central bus vs library: should the Interchange be a **network service** or a **shared SDK**?  
- How do we route requests across multiple model providers (cost, latency, capability)?  
- What data is persisted for explainability vs excluded for privacy and cost?  
- How do we enforce **consent** and **subscription tier** at the AI edge?  
- Where do embeddings and **optional Vector DB** retrieval (ADR-009) plug in?

---

## Options

### Option A — Per-Service Direct Integration
Each microservice integrates with AI providers independently (SDK or HTTP).

**Pros**
- Simple to start; no central dependency.

**Cons**
- Duplicated logic for auth, retries, cost tracking, consent.  
- Inconsistent observability and explainability.  
- Hard to switch models or providers globally.

---

### Option B — Shared Client Library Only
Provide a standard SDK that wraps AI provider calls with logging and cost headers.

**Pros**
- Faster adoption; minimal infra.  
- Some consistency for telemetry and cost tags.

**Cons**
- Still fragmented policies and routing.  
- Requires coordinated upgrades across all services.  
- Limited runtime governance and throttling.

---

### Option C — Central AI Interchange Service (Recommended)
Introduce a **network service** that becomes the **single entry point** for AI tasks.  
It standardises **task schemas**, **policy enforcement**, **provider routing**, **cost tracking**, and **explainability logging**.  
A thin SDK forwards requests to the Interchange.

**Pros**
- Consistent governance (consent, PII, entitlements).  
- Centralised **cost**, **rate limiting**, and **routing** across providers.  
- Uniform **observability** and **audit** with replay capability.  
- Pluggable **RAG** via optional Vector DB (ADR-009).  

**Cons**
- New runtime dependency and scaling surface.  
- Requires careful SLOs to avoid becoming a bottleneck.

---

## Recommendation

Adopt **Option C – Central AI Interchange Service** that fronts all AI inference and retrieval.

**Key decisions**
1. **Unified Task API**: standard request envelope (`task_type`, `inputs_ref`, `consent_ref`, `tier`, `trace_id`).  
2. **Policy Gate**: enforce **consent**, **redaction**, **subscription tier** (ADR-012) before calling models.  
3. **Provider Router**: route by **capability**, **cost**, **latency**, **fallbacks**; support A/B and canary.  
4. **Cost & Usage Metering**: per-call token and time accounting; export to billing analytics (ADR-007) and dashboards.  
5. **Explainability Journal**: store minimal prompt metadata, model, version, decision rationale; hash-chain into **Audit Log** (ADR-011).  
6. **Optional Retrieval**: integrate **Vector DB** for RAG-style context (ADR-009).  
7. **Observability**: OpenTelemetry spans with unified labels (ADR-013); per-task SLOs.

---

## Consequences

**Positive**
- One place to manage **costs, consent, and controls** for all AI usage.  
- Faster provider swaps and experiments without app changes.  
- Uniform observability, auditability, and explainability.

**Trade-offs**
- Interchange adds a network hop and must meet strict SLOs.  
- Requires migration effort from direct integrations.  
- Needs strong versioning for task schemas and model policies.

---

## Implementation Details (High-level)

| Component | Responsibility | Notes |
|---|---|---|
| **AI Interchange API** | Single entry for AI tasks; validates policy and routes | Exposes REST and async endpoints |
| **Policy & Consent Gate** | Check consent, PII, subscription tier | Integrates with ADR-012 and privacy registry |
| **Provider Router** | Select model provider based on rules and health | Supports canary, A/B, cost caps |
| **RAG Connector (optional)** | Query Vector DB for context retrieval | See ADR-009; cached embeddings |
| **Cost Meter & Ledger** | Record tokens, time, provider charges | Exports to ADR-007; logs to ADR-011 |
| **Explainability Journal** | Minimal prompt/output metadata for replay | Hash-linked to ADR-011 for tamper-evidence |
| **OTel/Observability** | Traces, metrics, error budgets | ADR-013 SLOs and dashboards |
| **Client SDK** | Thin wrapper used by services | Enforces schema and correlation IDs |

**Sequence Example**

---

## Risks and Mitigations

| Risk                             | Likelihood | Impact | Mitigation                                                 |
| -------------------------------- | ---------: | -----: | ---------------------------------------------------------- |
| Interchange becomes a bottleneck |        Med |   High | Horizontal scale, per-tenant rate limits, circuit breakers |
| Provider outage or drift         |        Med |   High | Multi-provider routing, health checks, fallbacks           |
| Sensitive data leakage           |        Low |   High | Redaction policies, data minimisation, consent enforcement |
| Cost overruns                    |        Med |    Med | Per-team budgets, quotas, cost alerts, hard caps           |
| Explainability storage bloat     |        Med |    Med | Minimal journaling with TTL, sampled payloads              |
| Schema/version sprawl            |        Med |    Med | Versioned task contracts, SDK validation in CI             |
| Privacy non-compliance           |        Low |   High | Pseudonymisation, EU residency, DPIAs, audit hooks         |

---

## Alternatives Considered

* Per-service direct integration — rejected for governance and cost visibility gaps.
* SDK-only wrapper — rejected for limited runtime policy enforcement and routing.
* Central Interchange with thin SDK — chosen for unified control, cost management, and explainability.

## Links

* ADR-007 – Data Platform Architecture
* ADR-009 – Personalisation / Concierge Service Architecture
* ADR-011 – Immutable Audit Log Architecture
* ADR-012 – Premium Subscription Model Integration
* ADR-013 – Observability & Metrics Standardisation
* ADR-005 – Routing Solver (VRP-TW)
* ADR-006 – Alerts & Theft Detection Logic
* ADR-010 – Routing & Hub-Slot Reservation Integration
